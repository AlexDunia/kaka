import{D as f,G as D,r as S,c as m}from"./index-Coq0l3Fl.js";import{v as E,u as h}from"./auth-BUdO578h.js";const g="purchases",q=()=>{localStorage.getItem(g)||localStorage.setItem(g,JSON.stringify([]))},y=()=>(q(),JSON.parse(localStorage.getItem(g)||"[]")),A=r=>y().filter(a=>a.userId===r),T=async r=>{const{eventId:n,userId:a,quantity:u}=r,s=f.getEventById(n);if(!s)throw new Error("Event not found");if(s.availableTickets<u)throw new Error("Not enough tickets available");const i={id:E(),eventId:n,userId:a,eventTitle:s.title,eventDate:s.date,eventLocation:s.location,quantity:u,pricePerTicket:s.price,totalPrice:s.price*u,purchaseDate:new Date().toISOString(),status:"confirmed"};f.updateEvent(n,{availableTickets:s.availableTickets-u});const e=y();return e.push(i),localStorage.setItem(g,JSON.stringify(e)),i},b=async(r,n)=>{const a=y(),u=a.findIndex(e=>e.id===r&&e.userId===n);if(u===-1)throw new Error("Purchase not found");const s=a[u];if(s.status!=="confirmed")throw new Error("Cannot cancel this purchase");s.status="cancelled",s.cancelDate=new Date().toISOString(),a[u]=s;const i=f.getEventById(s.eventId);return i&&f.updateEvent(s.eventId,{availableTickets:i.availableTickets+s.quantity}),localStorage.setItem(g,JSON.stringify(a)),s},k=()=>{const r=y(),n=f.getAllEvents(),a=r.reduce((e,l)=>l.status==="confirmed"?e+l.totalPrice:e,0),u={};n.forEach(e=>{u[e.category]=0}),r.forEach(e=>{if(e.status==="confirmed"){const l=n.find(w=>w.id===e.eventId);l&&(u[l.category]+=e.quantity)}});const s={};r.forEach(e=>{e.status==="confirmed"&&(s[e.eventId]||(s[e.eventId]={eventId:e.eventId,eventTitle:e.eventTitle,quantity:0,revenue:0}),s[e.eventId].quantity+=e.quantity,s[e.eventId].revenue+=e.totalPrice)});const i=Object.values(s).sort((e,l)=>l.quantity-e.quantity).slice(0,5);return{totalRevenue:a,totalTicketsSold:r.reduce((e,l)=>l.status==="confirmed"?e+l.quantity:e,0),totalPurchases:r.filter(e=>e.status==="confirmed").length,salesByCategory:u,topSellingEvents:i}},d={getAllPurchases:y,getPurchasesByUser:A,createPurchase:T,cancelPurchase:b,getPurchaseStats:k},U=D("purchases",()=>{const r=S([]),n=S(!1),a=S(null),u=async()=>{const c=h();if(!c.user)return[];n.value=!0,a.value=null;try{const t=await d.getPurchasesByUser(c.user.id);return r.value=t,t}catch(t){throw a.value=t.message||"Failed to fetch purchase history",t}finally{n.value=!1}},s=async()=>{if(!h().isAdmin)return a.value="Unauthorized",[];n.value=!0,a.value=null;try{const t=await d.getAllPurchases();return r.value=t,t}catch(t){throw a.value=t.message||"Failed to fetch purchases",t}finally{n.value=!1}},i=async c=>{const t=h();if(!t.user)throw a.value="You must be logged in to purchase tickets",new Error("Authentication required");n.value=!0,a.value=null;try{const o={...c,userId:t.user.id},v=await d.createPurchase(o);return r.value.push(v),v}catch(o){throw a.value=o.message||"Failed to complete purchase",o}finally{n.value=!1}},e=async c=>{const t=h();if(!t.user)throw a.value="You must be logged in to cancel a purchase",new Error("Authentication required");n.value=!0,a.value=null;try{const o=await d.cancelPurchase(c,t.user.id),v=r.value.findIndex(I=>I.id===c);return v!==-1&&(r.value[v]=o),o}catch(o){throw a.value=o.message||"Failed to cancel purchase",o}finally{n.value=!1}},l=async()=>{if(!h().isAdmin)throw a.value="Unauthorized",new Error("Admin privileges required");n.value=!0,a.value=null;try{return await d.getPurchaseStats()}catch(t){throw a.value=t.message||"Failed to fetch purchase statistics",t}finally{n.value=!1}},w=m(()=>{const c=new Date;return r.value.filter(t=>t.status==="confirmed"&&new Date(t.eventDate)>c).sort((t,o)=>new Date(t.eventDate)-new Date(o.eventDate))}),p=m(()=>{const c=new Date;return r.value.filter(t=>new Date(t.eventDate)<c).sort((t,o)=>new Date(o.eventDate)-new Date(t.eventDate))}),P=m(()=>r.value.filter(c=>c.status==="confirmed").reduce((c,t)=>c+t.totalPrice,0));return{purchases:r,loading:n,error:a,upcomingPurchases:w,pastPurchases:p,totalSpent:P,fetchUserPurchases:u,fetchAllPurchases:s,createPurchase:i,cancelPurchase:e,getPurchaseStats:l}});export{d as p,U as u};
